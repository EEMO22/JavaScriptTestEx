function solution(n) {
  function DFS(L) {
    if (L == 0) {
      return;  //  return -> 반환, 종료
    } else {
      // console.log(L); -> 1, 2, 3 출력하고 싶은데 3, 2, 1이 나옴, 그러면 호출 아래에서 출력
      DFS(L-1); //  자기 자신을 호출
      console.log(L);
    }
  }

  DFS(n)
}

solution(3);

/* 
console.log(L)의 위치에 따라 출력 순서가 달라지는 이유는 무엇일까?

스택에는 DFS(3)의 경우,
  매개변수 L = 3,
  지역변수 (자신이 가진 변수들 정보)
  복귀주소 (DFS 2열부터 10열까지 처리한 후 호출된 위치인 12열로 돌아갈 정보)
등이 담겨있음

순차적으로 라인을 읽다가 7열, 즉 자신 호출되는 순간 하위 열 무시하고 2열로 돌아감
DFS(2)가 호출되어서,
스택 가장 바닥의 DFS(3)는 대기 상태가 되고 그 위에 DFS(2)가 생성됨
스택은 항상 맨 위에 있는 함수가 작동하게 된다
DFS(2)와 DFS(1)의 경우도 마찬가지
DFS(1) 이후에 L == 0이 되면, 4열에서 참이되어 리턴, 끝!(pop)
  리턴 시키면 이제 가지고 있는 복귀주소는 (내가 어디까지 처리했냐 하면) 
  DFS(1)의 7열인 것임
  왜냐하면 7열 아래로는 진행하지 않았고 (재귀호출하느라) 이제 대기상태 처리 ㄱ
  console 출력 시작, stack이므로 위에서부터 처리(pop 진행)

  그러면 이제 DFS(2)의 7열까지만 처리한 거 생각나서 그 아래로 다시 진행, pop
  ...

  그래서 1, 2, 3 순서로 출력이 된다.
  처음 위치였으면 console.log(L)까지도 실행되었을테니 3, 2, 1이 순차적 나오는 것
*/